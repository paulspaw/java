1.继承：三大特征之一 🌰：Inherit.java
    //概念
        从已有的类创建新类的过程
        1.被继承的类被称为父类(超类)，继承父类的类叫做子类(派生类)
        2.继承是指一个对象直接使用另一个对象的属性和方法
        3.通过继承可以实现代码重用
    //⚠️语法：
        [访问权限] class 子类名 extends 父类名{
            类体定义;
        }
    // protected
        受保护的访问权限修饰符，用于修饰属性和方法，使用protected修饰的属性和方法可以被子类继承
        在继承关系中使用

    //⚠️⚠️⚠️：
        1.继承一个父类，只能继承非私有的数据(属性，方法)
        2.创建对象会调用构造方法，调用构造方法不一定就是创建对象
        3.实例化子类对象，会先调用父类的构造方法，如果父类中没有默认的构造方法，那么子类必须显示的要通过
          super(...)来调用父类的带参构造方法，super也只能在子类构造方法中的第一句
        4.当父类中没有无参构造方法时，子类必须显示的调用父类的带参构造方法
    
    //限制：
        1，继承只能实现单继承，一个类只能继承一个父类
        2.允许多层继承
        3.继承只能继承非私有数据
        4.构造方法不能被继承
        5.创建子类对象时，父类的构造方法也会被调用，因为子类要使用父类的数据，那么就要通过父类的构造方法来初始化数据
          如果创建子类对象时使用默认的构造方法，那么父类的默认构造方法也会被使用
          如果创建子类对象时使用带参数的的构造方法，那么父类的默认构造方法也会被使用
    //好处：
        1.提高代码的复用性
        2.提高代码的维护性
        3.让类与类之间产生关系，是多态的前提
    //缺点：
        增强了类与类之间的耦合性
    //开发原则：
        高内聚，低耦合
    //子类的实例化过程
        子类实例化操作的时候，首先会先让其父类进行初始化操作，之后子类再自己进行实例化操作
        调用构造方法不代表会生成对象
2.方法的重写 override 🌰：Inherit.java 重写eat()
    又称为方法的覆盖
    //目的：同一个行为 具备不同的表现形式

    重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法。
    //特性：
        1.发生在子父类中，方法重写的两个方法返回值，方法名，参数列表必须完全一致（子类重写父类的方法）
        2.子类抛出的异常不能超过父类相应方法抛出的异常（子类一场不能大于父类异常）
        3.子类方法的访问级别不能低于父类相应方法的访问级别（子类访问级别不能低于父类访问级别）
        4.父类的方法若使用private,static,final(最终)任意修饰符修饰，那么不能被子类重写
//⚠️面试题：
    override 和 overload 的区别：
        overload: 方法名相同，参数列表不同，与返回值无关，发生在同一个类中
        override: 方法名相同，参数列表相同，返回值也相同，发生在子父类中，子类访问修饰 >= 父类的访问修饰符
                  子类的异常声明必须 <= 父类的异常声明。 方法被private，static，final修饰，方法就不能被重写

3.super关键字 🌰：Inherit.java
    1.使用super调用父类中的属性，可以从父类实例处获得信息
    2.使用super调用父类中的方法，可以委托父类对象完成某些事情
    3.使用super调用父类中的构造方法（super(实参)形式），必须在子类构造方法的第一条语句，调用父类中相应的构造方法
      若不显示的写出来，默认调用父类的无参构造方法，比如：super();
    
4.final关键字 🌰：DefFinal.java
    1.声明一个常量  
        1.修饰属性或者修饰局部变量（最终变量）也称为常量
        2.声明一个属性，就是常量，命名规范建议全部大写
        3.常量必须在定义时或者在构造器中初始化
    2.声明一个方法：
        最终方法，可以被子类继承但是不能进行重写
    3.声明一个类：
        该类转变为最终类，没有子类，无法被继承
    4.在方法参数中使用final，该方法内部不能修改参数的值（在内部类中详解）

5.抽象类 🌰：AbstractClass.java
    //概念：
        1.很多具有相同特征和行为的"对象"可以抽象为一个类，很多具有相同特征和行为的"类"可以抽象为一个抽象类
        2.使用abstract关键字声明的类为 抽象类
    //定义
        abstract class Animal{
            public abstract void move();
        }
        abstract class Person extends Animal{
            private String name;
            public abstract void eat(); //抽象方法
        }
    //特点：
        1.抽象类不能运行的 专门用来被继承的
        2.抽象方法只有声明，没有实现
        3.⚠️继承抽象类的具体类必须实现所有抽象方法！
    //⚠️⚠️⚠️规则：
        1.抽象类可以没有抽象方法，有抽象方法的类必须是抽象类
        2.非抽象类继承抽象类必须实现所有抽象方法
        3.抽象类可以继承抽象类，可以不实现父类抽象方法
        4.抽象类可以有方法实现和属性
        5.抽象类不能被实例化
        6.抽象类不能声明为final
        7.抽象类可以有构造方法
6.⚠️接口 🌰：DefInterface.java
    //定义格式
        interface 接口名称{
            全局常量;
            抽象方法;
        }
    //概念：
        1.是一组行为的规范、定义，没有实现（jdk1.8带实现的默认方法）
        2.使用接口，可以让我们的程序更加利于变化
        3.接口是面向对象编程体系中的思想精髓之一
        4.面向对象设计法则：基于接口编程
    //规则：
        1.定义一个接口，使用interface关键字
        2.在一个接口中，只能定义常量，抽象方法，jdk1.8后可以定义默认的实现方法
        3.借口可以继承多个接口 extends 接口1,接口2
        4.一个具体类实现接口使用 implements 关键字
        5.一个类可以实现多个接口
        6.抽象类实现接口可以不实现接口的方法
        7.在接口中定义的方法没有声明 访问修饰符，默认为public
        8.接口不能有构造方法
        9.接口不能被实例化
    //面向对象设计原则：
        1.对修改关闭，对扩展开放
        2.面向接口编程
7.多态 面向对象三大特性之一 🌰：DefPolymorohism.java
    //定义
        对象在运行过程中的多种形态
        可分为两类：
            1.方法的重载与重写
            2.对象的多态性
    //用父类的引用指向子类对象（用大的类型去接受小的类型，向上转型、自动转换）
        Chicken homechicken = new HomeChicken();
    //结论
        在编程时针对抽象类型的编写代码，称为面向抽象编程（或面向接口编程）
        父类通常都定义为抽象类、接口
        
    